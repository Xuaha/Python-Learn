# 算法复杂度

> **算法复杂度（Algorithm complexity）**：在问题的输入规模为 n 的条件下，程序的时间使用情况和空间使用情况。

算法所追求的就是 **所需运行时间更少（时间复杂度更低）**、**占用内存空间更小（空间复杂度更低）**。所以进行「算法分析」，就是从运行时间情况、空间使用情况两方面对算法进行分析。

## 时间复杂度
### 1.1 时间复杂度简介
> **时间复杂度（Time Complexity）**：在问题的输入规模为 n 的条件下，算法运行所需要花费的时间，可以记作为 T(n)。

我们将 **基本操作次数** 作为时间复杂度的度量标准。换句话说，时间复杂度跟算法中基本操作次数的数量正相关。

- **基本操作** ：算法执行中的每一条语句。每一次基本操作都可在常数时间内完成

比如两个整数相加的操作，如果两个数的规模不大，运行时间不依赖于整数的位数，则相加操作就可以看做是基本操作。

反之，如果两个数的规模很大，相加操作依赖于两个数的位数，则两个数的相加操作不是一个基本操作，而每一位数的相加操作才是一个基本操作。

下面通过一个具体例子来说明一下如何计算时间复杂度：

```Python
def algorithm(n):
    fact = 1
    for i in range(1, n + 1):
        fact *= i
    return fact
```

把上述算法中所有语句的执行次数加起来 $1 + n + n + 1 = 2n + 2$，可以用一个函数 $f(n)$ 来表达语句的执行次数：$f(n) = 2n + 2$。

则时间复杂度的函数可以表示为：$T(n) = O(f(n))$。它表示的是随着问题规模 n 的增大，算法执行时间的增长趋势跟 $f(n)$ 相同。$O$ 是一种渐进符号，$T(n)$ 称作算法的 **渐进时间复杂度（Asymptotic time complexity）**，简称为 **时间复杂度**。

### 1.2 渐进符号

**「渐进符号」** 实际上是专门用来刻画函数的增长速度的。简单来说，渐进符号只保留了 **最高阶幂**，忽略了一个函数中增长较慢的部分，比如 **低阶幂**、**系数**、**常量**。因为当问题规模变的很大时，这几部分并不能左右增长趋势，所以可以忽略掉。

经常用到的渐进符号有三种： $\Theta$、$O$、$\Omega$。

### 时间复杂度计算

- **找出算法中的基本操作（基本语句）**：算法中执行次数最多的语句就是基本语句，通常是最内层循环的循环体部分。
- **计算基本语句执行次数的数量级**：只需要计算基本语句执行次数的数量级，即保证函数中的最高次幂正确即可。像最高次幂的系数和低次幂可以忽略。
- **用大 O 表示法表示时间复杂度**：将上一步中计算的数量级放入 O 渐进上界符号中。

同时，在求解时间复杂度还要注意一些原则：

- **加法原则**：总的时间复杂度等于量级最大的基本语句的时间复杂度。

如果 $T_1(n) = O(f_1(n))$，$T_2(n) = O(f_2(n))$，$T(n) = T_1(n) + T_2(n)$，则 $T(n) = O(f(n)) = max(O(f_1(n)), O(f_2(n))) = O(max(f_1(n), f_2(n)))$。

- **乘法原则**：循环嵌套代码的复杂度等于嵌套内外基本语句的时间复杂度乘积。

如果 $T_1 = O(f_1(n))$，$T_2(n) = O(f_2(n))$，$T(n) = T_1(n)T_2(n)$，则 $T(n) = O(f(n)) = O(f_1(n))O(f_2(n)) = O(f_1(n)f_2(n))$。


下面通过实例来说明如何计算时间复杂度

#### 常数 $O(1)$

一般情况下，只要算法中不存在循环语句、递归语句，其时间复杂度都为 $O(1)$。

$O(1)$ 只是常数阶时间复杂度的一种表示方式，并不是指只执行了一行代码。只要代码的执行时间不随着问题规模 n 的增大而增长，这样的算法时间复杂度都记为 $O(1)$。

```Python
def algorithm(n):
    a = 1
    b = 2
    res = a * b + n
    return res
```

上述代码虽然有 4 行，但时间复杂度也是 $O(1)$，而不是 $O(3)$。

#### 线性 $O(n)$

一般含有非嵌套循环，且单层循环下的语句执行次数为 n 的算法涉及线性时间复杂度。这类算法随着问题规模 n 的增大，对应计算次数呈线性增长

```Python
def algorithm(n):
    sum = 0
    for i in range(n):
        sum += 1
    return sum
```
上述代码中 `sum += 1` 的执行次数为 n 次，所以这段代码的时间复杂度为 $O(n)$。

#### 平方 $O(n^2)$

一般含有双层嵌套，且每层循环下的语句执行次数为 n 的算法涉及平方时间复杂度。这类算法随着问题规模 n 的增大，对应计算次数呈平方关系增长

```Python
def algorithm(n):
    res = 0
    for i in range(n):
        for j in range(n):
            res += 1
    return res
```

上述代码中，`res += 1` 在两重循环中，根据时间复杂度的乘法原理，这段代码的执行次数为 $n^2$ 次，所以其时间复杂度为 $O(n^2)$。

#### 阶乘 $O(n!)$

阶乘时间复杂度一般出现在与「全排列」、「旅行商问题暴力解法」相关的算法中。这类算法随着问题规模 n 的增大，对应计算次数呈阶乘关系增长。

```Python
def permutations(arr, start, end):
    if start == end:
        print(arr)
        return
 
    for i in range(start, end):
        arr[i], arr[start] = arr[start], arr[i]
        permutations(arr, start + 1, end)
        arr[i], arr[start] = arr[start], arr[i]
```

上述代码中实现「全排列」使用了递归的方法。假设数组 `arr` 长度为 `n`，第一层 `for` 循环执行了 `n` 次，第二层 `for` 循环执行了 `n - 1` 次。以此类推，最后一层 `for` 循环执行了 `1` 次，将所有层 `for` 循环的执行次数累乘起来为 $n * (n - 1) * (n - 2) * ... * 2 * 1 = n!$ 次。则整个算法的 `for` 循环中基本语句的执行次数为 $n!$ 次，所以对应时间复杂度为 $O(n!)$。

#### 对数 $O(log_2n)$

对数时间复杂度一般出现在「二分查找」、「分治」这种一分为二的算法中。这类算法随着问题规模 n 的增大，对应的计算次数呈对数关系增长。

```Python
def algorithm(n):
    cnt = 1
    while cnt < n:
        cnt *= 2
    return cnt
```

上述代码中 `cnt = 1` 的时间复杂度为 O(1) 可以忽略不算。while 循环体中 `cnt` 从 1 开始，每循环一次都乘以 2。当大于 n 时循环结束。变量 `cnt` 的取值是一个等比数列：$2^0，2^1，2^2，…，2^x$，根据 $2^x = n$，可以得出这段循环体的执行次数为 $log_2n$。所以这段代码的时间复杂度为 $O(log_2n)$。
#### 线性对数 $O(n log_2 n)$

 线性对数一般出现在排序算法中，例如「快速排序」、「归并排序」、「堆排序」等。这类算法随着问题规模 n 的增大，对应的计算次数呈线性对数关系增长。

```Python
def algorithm(n):
    cnt = 1
    res = 0
    while cnt < n:
        cnt *= 2
        for i in range(n):
            res += 1
    return res
```

上述代码中外层循环的时间复杂度为 $O(log_2 n)$，内层循环的时间复杂度为 $O(n)$，且两层循环相互独立，则总体时间复杂度为 $O(n log_2 n)$。

### 常见的复杂度关系

根据从小到大排序，常见的算法复杂度主要有：$O(1)$ < $O(log_2 n)$ < $O(n)$ < $O(n log_2n)$ < $O(n^2)$ < $O(n^3)$ < $O(2^n)$ < $O(n!)$ < $O(n^n)$。

### 最佳、最坏、平均时间复杂度

时间复杂度是一个关于输入问题规模 n 的函数。但是因为输入问题的内容不同，习惯将「时间复杂度」分为「最佳」、「最坏」、「平均」三种情况。这三种情况的具体含义如下：

- **最佳时间复杂度**：每个输入规模下用时最短的输入所对应的时间复杂度。
- **最坏时间复杂度**：每个输入规模下用时最长的输入所对应的时间复杂度。
- **平均时间复杂度**：每个输入规模下所有可能的输入所对应的平均用时复杂度（随机输入下期望用时的复杂度

举例：

```Python
def find(nums, val):
    pos = -1
    for i in range(n):
        if nums[i] == val:
            pos = i
            break
    return pos
```

这段代码要实现的功能是：从一个整数数组 `nums` 中查找值为 `val` 的变量出现的位置。如果不考虑 `break` 语句，根据「2.3 时间复杂度计算」中讲的分析步骤，这个算法的时间复杂度是 $O(n)$，其中 n 代表数组的长度。

但是如果考虑 `break` 语句，那么就需要考虑输入的内容了。如果数组中第 1 个元素值就是 `val`，那么剩下 `n - 1` 个数据都不要遍历了，那么时间复杂度就是 $O(1)$，即最佳时间复杂度为 $O(1)$。如果数组中不存在值为 `val` 的变量，那么就需要把整个数组遍历一遍，时间复杂度就变成了 $O(n)$，即最差时间复杂度为 $O(n)$。


## 空间复杂度

